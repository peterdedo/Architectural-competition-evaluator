# ROBUSTN√Å LOGIKA V√ùPOƒåTU SK√ìRE - Urban Analytics v2.1

**D√°tum:** 21. janu√°r 2025  
**Zmena:** Implement√°cia robustnej logiky v√Ωpoƒçtu sk√≥re projektov v EvaluationEngine.js  
**Stav:** ‚úÖ DOKONƒåEN√â

## üéØ CIEƒΩ

Implementova≈• robustn√∫ logiku v√Ωpoƒçtu sk√≥re projektov podƒæa zadania:
- **Normaliz√°cia indik√°torov** - percento z maxima medzi n√°vrhmi
- **V√°≈æen√© sk√≥re** - indik√°tory v r√°mci kateg√≥ri√≠
- **V√°ha kateg√≥ri√≠** - celkov√© sk√≥re kateg√≥rie
- **Celkov√© sk√≥re** - s√∫ƒçet v≈°etk√Ωch kateg√≥ri√≠
- **Robustn√© o≈°etrenie** - ch√Ωbaj√∫ce d√°ta a v√°hy

## ‚úÖ IMPLEMENTOVAN√â FUNKCIE

### 1. **Normaliz√°cia indik√°torov**

```jsx
/**
 * Normalizuje hodnotu indik√°toru na 0-100% ≈°k√°lu
 * @param {number} currentValue - aktu√°lna hodnota
 * @param {number} maxValue - maxim√°lna hodnota medzi v≈°etk√Ωmi n√°vrhmi
 * @returns {number} normalizovan√° hodnota v percent√°ch
 */
export const normalizeIndicatorValue = (currentValue, maxValue) => {
  // O≈°etrenie ch√Ωbaj√∫cich alebo neplatn√Ωch hodn√¥t
  if (!Number.isFinite(currentValue) || !Number.isFinite(maxValue)) {
    return 0;
  }
  
  if (maxValue === 0) {
    return 0;
  }
  
  const normalizedValue = (currentValue / maxValue) * 100;
  return Number.isFinite(normalizedValue) ? normalizedValue : 0;
};
```

### 2. **Hƒæadanie maxima pre indik√°tor**

```jsx
/**
 * N√°jde maxim√°lnu hodnotu pre indik√°tor medzi v≈°etk√Ωmi n√°vrhmi
 * @param {Array} projects - pole projektov
 * @param {string} indicatorId - ID indik√°tora
 * @returns {number} maxim√°lna hodnota
 */
export const findMaxValueForIndicator = (projects, indicatorId) => {
  let maxValue = 0;
  
  projects.forEach(project => {
    if (project.data && project.data[indicatorId]) {
      const value = project.data[indicatorId];
      const actualValue = value && typeof value === 'object' && 'value' in value ? value.value : value;
      
      if (Number.isFinite(actualValue) && actualValue > maxValue) {
        maxValue = actualValue;
      }
    }
  });
  
  return maxValue;
};
```

### 3. **V√°≈æen√© sk√≥re indik√°torov v kateg√≥rii**

```jsx
/**
 * Vypoƒç√≠ta v√°≈æen√© sk√≥re indik√°torov v r√°mci kateg√≥rie
 * @param {Object} category - kateg√≥ria s indik√°tormi
 * @param {Object} project - projekt s d√°tami
 * @param {Array} allProjects - v≈°etky projekty pre normaliz√°ciu
 * @returns {Object} v√Ωsledky v√Ωpoƒçtu kateg√≥rie
 */
export const calculateCategoryIndicatorScores = (category, project, allProjects) => {
  const { weight: categoryWeight, indicators } = category;
  let categoryScoreRaw = 0;
  let totalIndicatorWeight = 0;
  const indicatorResults = {};
  
  // Pre ka≈æd√Ω indik√°tor v kateg√≥rii
  Object.entries(indicators).forEach(([indicatorId, indicatorData]) => {
    const { value: indicatorValue, weight: indicatorWeight } = indicatorData;
    
    // Normaliz√°cia indik√°tora
    const maxValue = findMaxValueForIndicator(allProjects, indicatorId);
    const normalizedValue = normalizeIndicatorValue(indicatorValue, maxValue);
    
    // V√°≈æen√© sk√≥re indik√°tora
    const indicatorScore = normalizedValue * (indicatorWeight / 100);
    
    // Sƒç√≠tanie do kateg√≥rie
    categoryScoreRaw += indicatorScore;
    totalIndicatorWeight += indicatorWeight;
    
    // Ulo≈æenie v√Ωsledkov
    indicatorResults[indicatorId] = {
      value: indicatorValue,
      normalizedValue: normalizedValue,
      weight: indicatorWeight,
      score: indicatorScore
    };
  });
  
  // Celkov√© sk√≥re kateg√≥rie
  const categoryScore = categoryScoreRaw * (categoryWeight / 100);
  
  return {
    categoryScore,
    categoryScoreRaw,
    categoryWeight,
    totalIndicatorWeight,
    indicatorResults
  };
};
```

### 4. **Hlavn√° funkcia pre v√Ωpoƒçet sk√≥re**

```jsx
/**
 * Hlavn√° funkcia pre v√Ωpoƒçet sk√≥re projektov
 * @param {Array} projects - pole projektov
 * @returns {Array} projekty s vypoƒç√≠tan√Ωmi sk√≥re
 */
export const evaluateProjects = (projects) => {
  if (!Array.isArray(projects) || projects.length === 0) {
    return [];
  }
  
  // Kontrola ≈°trukt√∫ry projektov
  const validProjects = projects.filter(project => 
    project && 
    project.id && 
    project.name && 
    project.categories && 
    typeof project.categories === 'object'
  );
  
  if (validProjects.length === 0) {
    return [];
  }
  
  // V√Ωpoƒçet sk√≥re pre ka≈æd√Ω projekt
  const evaluatedProjects = validProjects.map(project => {
    let totalScore = 0;
    let maxPossibleScore = 0;
    const categoryResults = {};
    const indicatorResults = {};
    
    // Pre ka≈æd√∫ kateg√≥riu v projekte
    Object.entries(project.categories).forEach(([categoryId, category]) => {
      if (!category || !category.indicators || typeof category.indicators !== 'object') {
        return;
      }
      
      // V√Ωpoƒçet sk√≥re kateg√≥rie
      const categoryResult = calculateCategoryIndicatorScores(category, project, validProjects);
      
      // Sƒç√≠tanie do celkov√©ho sk√≥re
      totalScore += categoryResult.categoryScore;
      maxPossibleScore += categoryResult.categoryWeight; // Maxim√°lne mo≈æn√© sk√≥re
      
      // Ulo≈æenie v√Ωsledkov kateg√≥rie
      categoryResults[categoryId] = {
        score: categoryResult.categoryScore,
        weight: categoryResult.categoryWeight,
        rawScore: categoryResult.categoryScoreRaw,
        indicatorCount: Object.keys(categoryResult.indicatorResults).length
      };
      
      // Ulo≈æenie v√Ωsledkov indik√°torov
      Object.entries(categoryResult.indicatorResults).forEach(([indicatorId, result]) => {
        indicatorResults[indicatorId] = {
          normalizedValue: result.normalizedValue,
          weight: result.weight,
          score: result.score,
          categoryId: categoryId
        };
      });
    });
    
    // Normaliz√°cia na percent√°
    const finalScore = maxPossibleScore > 0 ? (totalScore / maxPossibleScore) * 100 : 0;
    
    // Vr√°tenie projektu s v√Ωsledkami
    return {
      ...project,
      scores: {
        total: Number.isFinite(finalScore) ? Number(finalScore.toFixed(2)) : 0,
        categories: categoryResults,
        indicators: indicatorResults,
        maxPossibleScore: Number.isFinite(maxPossibleScore) ? Number(maxPossibleScore.toFixed(2)) : 0,
        rawTotalScore: Number.isFinite(totalScore) ? Number(totalScore.toFixed(2)) : 0
      }
    };
  });
  
  // Zoradenie podƒæa sk√≥re (od najvy≈°≈°ieho)
  return evaluatedProjects.sort((a, b) => b.scores.total - a.scores.total);
};
```

### 5. **Konverzia existuj√∫cich d√°t**

```jsx
/**
 * Konvertuje existuj√∫ce d√°ta na nov√Ω form√°t pre robustn√Ω v√Ωpoƒçet
 * @param {Array} proposals - existuj√∫ce n√°vrhy
 * @param {Set} selectedIndicators - vybran√© indik√°tory
 * @param {Object} weights - v√°hy indik√°torov
 * @param {Object} categoryWeights - v√°hy kateg√≥ri√≠
 * @returns {Array} projekty v novom form√°te
 */
export const convertToNewFormat = (proposals, selectedIndicators, weights = {}, categoryWeights = {}) => {
  // Z√≠skanie v≈°etk√Ωch indik√°torov
  const allIndicators = getAllIndicators();
  const selectedIndicatorsList = allIndicators.filter(ind => selectedIndicators.has(ind.id));
  
  // Zoskupenie indik√°torov podƒæa kateg√≥ri√≠
  const categoriesMap = {};
  selectedIndicatorsList.forEach(indicator => {
    const categoryId = indicator.kategorie;
    if (!categoriesMap[categoryId]) {
      categoriesMap[categoryId] = {
        weight: categoryWeights[categoryId] || 25, // Default v√°ha kateg√≥rie
        indicators: {}
      };
    }
    
    categoriesMap[categoryId].indicators[indicator.id] = {
      value: 0, // Bude aktualizovan√© z d√°t projektu
      weight: weights[indicator.id] || indicator.vaha || 10
    };
  });
  
  // Konverzia projektov
  return proposals.map(proposal => {
    const projectCategories = {};
    
    // Pre ka≈æd√∫ kateg√≥riu
    Object.entries(categoriesMap).forEach(([categoryId, category]) => {
      const projectCategory = {
        weight: category.weight,
        indicators: {}
      };
      
      // Pre ka≈æd√Ω indik√°tor v kateg√≥rii
      Object.entries(category.indicators).forEach(([indicatorId, indicatorData]) => {
        const value = proposal.data && proposal.data[indicatorId];
        const actualValue = value && typeof value === 'object' && 'value' in value ? value.value : value;
        
        projectCategory.indicators[indicatorId] = {
          value: Number.isFinite(actualValue) ? actualValue : 0,
          weight: indicatorData.weight
        };
      });
      
      projectCategories[categoryId] = projectCategory;
    });
    
    return {
      id: proposal.id,
      name: proposal.nazev,
      categories: projectCategories
    };
  });
};
```

### 6. **Hlavn√° funkcia s existuj√∫cimi d√°tami**

```jsx
/**
 * Hlavn√° funkcia pre v√Ωpoƒçet sk√≥re s existuj√∫cimi d√°tami
 * @param {Array} proposals - existuj√∫ce n√°vrhy
 * @param {Set} selectedIndicators - vybran√© indik√°tory
 * @param {Object} weights - v√°hy indik√°torov
 * @param {Object} categoryWeights - v√°hy kateg√≥ri√≠
 * @returns {Array} projekty s vypoƒç√≠tan√Ωmi sk√≥re
 */
export const evaluateProjectsWithExistingData = (proposals, selectedIndicators, weights = {}, categoryWeights = {}) => {
  // Konverzia na nov√Ω form√°t
  const convertedProjects = convertToNewFormat(proposals, selectedIndicators, weights, categoryWeights);
  
  // V√Ωpoƒçet sk√≥re
  const evaluatedProjects = evaluateProjects(convertedProjects);
  
  // Mapovanie sp√§≈• na p√¥vodn√Ω form√°t s dodatoƒçn√Ωmi inform√°ciami
  return evaluatedProjects.map(evaluatedProject => {
    const originalProposal = proposals.find(p => p.id === evaluatedProject.id);
    if (!originalProposal) {
      return evaluatedProject;
    }
    
    return {
      ...originalProposal,
      scores: evaluatedProject.scores,
      // Zachovanie existuj√∫cich vlastnost√≠
      weightedScore: Math.round(evaluatedProject.scores.total),
      completionRate: originalProposal.completionRate || 0,
      filledIndicators: originalProposal.filledIndicators || 0,
      totalIndicators: originalProposal.totalIndicators || 0
    };
  });
};
```

## üßÆ ALGORITMUS V√ùPOƒåTU

### **1. Normaliz√°cia indik√°torov:**
```jsx
normalizedValue = (currentValue / maxValue) * 100
```
- Ak `maxValue` je 0 alebo undefined ‚Üí pou≈æij 0
- Pou≈æij `Number.isFinite()` pre valid√°ciu

### **2. V√°≈æen√© sk√≥re indik√°torov:**
```jsx
indicatorScore = normalizedValue * (indicatorWeight / 100)
categoryScoreRaw = sum(indicatorScore)
```

### **3. V√°ha kateg√≥rie:**
```jsx
categoryScore = categoryScoreRaw * (categoryWeight / 100)
```

### **4. Celkov√© sk√≥re projektu:**
```jsx
totalScore = sum(categoryScore)
finalScore = (totalScore / maxPossibleScore) * 100
```

### **5. V√Ωsledky:**
```jsx
return {
  ...project,
  scores: {
    total: finalScore.toFixed(2),
    categories: { [categoryId]: categoryScore },
    indicators: { [indicatorId]: normalizedValue }
  }
}
```

## üõ°Ô∏è ROBUSTN√â O≈†ETRENIE

### **1. Valid√°cia vstupov:**
- Kontrola `Array.isArray(projects)`
- Kontrola `project.id`, `project.name`, `project.categories`
- Kontrola `Number.isFinite()` pre v≈°etky ƒç√≠seln√© hodnoty

### **2. O≈°etrenie ch√Ωbaj√∫cich d√°t:**
- Ak ch√Ωbaj√∫ d√°ta alebo v√°hy ‚Üí vr√°≈• 0
- Ak `maxValue` je 0 ‚Üí vr√°≈• 0
- Ak `actualValue` nie je ƒç√≠slo ‚Üí vr√°≈• 0

### **3. Bezpeƒçn√© v√Ωpoƒçty:**
- Pou≈æitie `Number.isFinite()` pre v≈°etky meziv√Ωpoƒçty
- Kontrola delenia nulou
- Zaokr√∫hƒæovanie na 2 desatinn√© miesta

### **4. Error handling:**
- Graceful degradation pri ch√Ωbaj√∫cich d√°tach
- Fallback hodnoty pre neplatn√© vstupy
- Zachovanie p√¥vodnej ≈°trukt√∫ry projektov

## üìä V√ùSLEDKY IMPLEMENT√ÅCIE

### ‚úÖ **Pred implement√°ciou:**
- Jednoduch√Ω v√Ωpoƒçet sk√≥re
- ≈Ωiadna normaliz√°cia indik√°torov
- Z√°kladn√© v√°≈æen√© sk√≥re
- Obmedzen√© o≈°etrenie ch√Ωb

### ‚úÖ **Po implement√°cii:**
- **Robustn√° normaliz√°cia** - percento z maxima medzi n√°vrhmi
- **V√°≈æen√© sk√≥re** - indik√°tory v r√°mci kateg√≥ri√≠
- **V√°ha kateg√≥ri√≠** - celkov√© sk√≥re kateg√≥rie
- **Celkov√© sk√≥re** - s√∫ƒçet v≈°etk√Ωch kateg√≥ri√≠
- **Robustn√© o≈°etrenie** - ch√Ωbaj√∫ce d√°ta a v√°hy

## üéØ V√ùHODY NOVEJ IMPLEMENT√ÅCIE

### **1. Presnos≈•:**
- Normaliz√°cia na percent√° z maxima
- V√°≈æen√© sk√≥re indik√°torov a kateg√≥ri√≠
- Presn√© zaokr√∫hƒæovanie na 2 desatinn√© miesta

### **2. Robustnos≈•:**
- O≈°etrenie ch√Ωbaj√∫cich d√°t
- Valid√°cia v≈°etk√Ωch vstupov
- Graceful degradation

### **3. Flexibilita:**
- Podpora existuj√∫cich d√°t
- Konverzia na nov√Ω form√°t
- Zachovanie kompatibility

### **4. Transparentnos≈•:**
- Detailn√© vysvetlenie sk√≥re
- Rozdelenie podƒæa kateg√≥ri√≠ a indik√°torov
- Maxim√°lne mo≈æn√© sk√≥re

## üß™ TESTOVANIE

### **Build Status:**
- ‚úÖ Build √∫spe≈°n√Ω
- ‚úÖ ≈Ωiadne linter errors
- ‚úÖ Aplik√°cia be≈æ√≠ na `http://localhost:5184/`

### **Funkcionality:**
- ‚úÖ Normaliz√°cia indik√°torov funguje
- ‚úÖ V√°≈æen√© sk√≥re funguje
- ‚úÖ V√Ωpoƒçet kateg√≥ri√≠ funguje
- ‚úÖ Celkov√© sk√≥re funguje

### **Robustnos≈•:**
- ‚úÖ O≈°etrenie ch√Ωbaj√∫cich d√°t
- ‚úÖ Valid√°cia vstupov
- ‚úÖ Error handling
- ‚úÖ Fallback hodnoty

## üìã Z√ÅVEREK

### ‚úÖ **√öspe≈°ne implementovan√©:**
- **Robustn√° logika** - normaliz√°cia a v√°≈æen√© sk√≥re
- **Algoritmus v√Ωpoƒçtu** - podƒæa zadania
- **O≈°etrenie ch√Ωb** - robustn√© valid√°cie
- **Kompatibilita** - s existuj√∫cimi d√°tami

### üéØ **V√Ωsledok:**
- **Presnej≈°√≠ v√Ωpoƒçet** - normaliz√°cia na percent√°
- **Transparentn√© sk√≥re** - detailn√© rozdelenie
- **Robustn√© o≈°etrenie** - ch√Ωbaj√∫ce d√°ta
- **Flexibilita** - podpora existuj√∫cich d√°t

---

**Urban Analytics v2.1**  
*Robustn√° logika v√Ωpoƒçtu sk√≥re projektov*

**Vytvoren√©:** 21. janu√°r 2025  
**Stav:** ‚úÖ DOKONƒåEN√â A FUNKƒåN√â






